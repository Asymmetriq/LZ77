
# Описание программы

## Краткое описание логики

 - Функция *compress* отвечает за сжатие строки байт. Она производит обработку строки *byteDataString*,
   работу со скользящим окном (заполнение обоих буферов *historyBuffer* и *lookaheadBuffer*), а также заполнение массива кодов-троек *encoded*.
   
 - Функция *decompress* отвечает за раскодировку кодов-троек обратно в строку.
 - Функция *getLongestPrefix()* отвечает за поиск наибольшей совпадающей подстроки и непосредственное кодирование подстрок тройками ⟨offset, length, next⟩. 
 При этом учитывается возможный нетривиальный сценарий, когда значение длины превышает значение смещения. Такой пример не совсем очевиден: «Вернуться на 1 символ назад в буфере и скопировать 7 символов, начиная с текущей позиции». Следующая интерпретация кодирующей пары может прояснить ситуацию: каждые 7 последующих символов совпадают (эквивалентны) с 1 символом перед ними. 
 - Функция *reset* отвечает за сброс всех буферов и массива кодов-троек.
 - Функция *pack* отвечает за упаковку несжатого файла. Она последовательно вызывает функции *readFileUncompressed*, *compress*, *createFileCompressed*, *reset*: чтение несжатого, сжатие, создание сжатого файла и сброс.
 - Функция *unpack* отвечает за распаковку сжатого файла. Она последовательно вызывает функции *readFileCompressed*, *decompress*, *createFileUncompressed*, *reset*: чтение сжатого, декомпрессия, создание несжатого файла и сброс.
 - Функция *readFileUncompressed* открывает несжатый файл и считывает его байтовое представление, интерпретируя каждый отдельный байт с помощью *char* и записывает итоговый массив символов в строку *std::string*. Так как char на подавляющем большинстве систем имеет размерность 8 бит (1 байт), то с помощью этого типа данных можно удобно работать с бинарным файлом.
 - Функция *createFileCompressed* создаёт выходной сжатый файл, побайтово записывая массив кодов-троек (элементы тройки *offset, length* сначала разбивается на байты с помощью вспомогательных функций).
 - Функция *intToBytes* разбивает *int* на 4 отдельных байта с помощью массива *char[4]*.
 - Функция *intFromBytes* получает *int* из массива *char[4]* в виде 4 отдельных байт .
 -  Функция *readFileCompressed* открывает сжатый файл и считывает его байтовое представление, разбивая байты (*char*) на коды-тройки ⟨offset, length, next⟩ (элементы тройки *offset, length* сначала переводятся в *int* с помощью вспомогательных функций).
 - Функция *createFileUncompressed* создаёт несжатый (прошедший процесс декомпрессии) файл.

## Использованные структуры данных

Для хранения и работы с байтовым представлением файла используется представление единичного байта с помощью *char*, полученные символы хранятся в строке *std::string*. Так как char на подавляющем большинстве систем *char* имеет размерность 8 бит (1 байт), то с помощью этого типа данных можно удобно работать с бинарным файлом. Интерфейс *std::string* облегчает работу с подстроками (ключевая особенность алгоритма).

## Оценка сложности 

 - Функция *getLongestPrefix*: 
 В лучшем случаи никогда не заходим во
   внутренний цикл: O(min(l,h), где l и h – размеры буферов
   В худшем каждый раз заходим: O(min(l^2^,h^2^ ))
 - Функция *compress*: 
 n разы вызываем *getLongestPrefix* в цикле. 
 

Получаем n * O(min(l^2^,h^2^ )) ≈ O(n^3^)

## Оценка использования памяти

Так как алгоритм работает с байтовым представлением файла, то строка *byteDataString* имеет размер, равный размеру файла в байтах (основная память). Буферы делят этот массив между собой
Затратами дополнительной памяти можно считать хранение массива кодов-троек. Если N – размер массива,  то получаем 3*N, O(N).
Также в худшем случае кодер не может найти совпадающую подстроку в словаре и выдает стандартный 3-компонентный код, пытаясь закодировать один символ. Следовательно, если все символы в строке разные, то на хранение каждого тратится 4 + 4 + 1  = 9 байт вместо 1.
