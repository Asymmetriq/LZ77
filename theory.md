
# Теоретическая часть 

## Условие задачи
Реализовать алгоритм сжатия LZ77. 

## Подходы к решению задачи

*Сжатие данных без потерь* — класс алгоритмов сжатия данных , при использовании которых закодированные данные однозначно могут быть восстановлены с точностью до бита, пикселя, вокселя и так далее. Сжатие без потерь используется, когда важна идентичность сжатых данных оригиналу. Обычный пример — исполняемые файлы и исходный код.

Помимо алгоритма LZ77, сжатие данных без потерь может производиться и другими алгоритмами, такими как: 

 - RLE 
 - Алгоритм Хаффмана
 - Алгоритм Шеннона-Фано
 - и другими

Ниже приведено описание заданного алгоритма, а также основные альтернативные подходы к решению задачи сжатия данных без потерь.

### Формальная постановка задачи

С использованием языка C++ реализовать алгоритм сжатия данных Лемпеля-Зива 77-го года (LZ77) для упаковки и распаковки файлов различного типа. 


### Алгоритм LZ77

#### Описание алгоритма и его свойства:

LZ77 — алгоритм сжатия данных без потерь, опубликованный Абрахамом Лемпелем и Якобом Зивом в 1977 году. Этот алгоритм, а также представленный в 1978 году LZ78, стали основой других алгоритмов семьи *LZ∗*: LZW, LZSS, LZMA и других. Оба алгоритма используют словарный подход. 

Основная идея алгоритма LZ77 заключается в кодировании одинаковых последовательностей элементов (подстрок) – замене повторений на ссылки на позиции в тексте, где такие подстроки уже встречались. То есть, если во входных данных какая-то подстрока встречается более одного раза, то последующие её вхождения можно заменить «ссылками» на её первый экземпляр.

#### Решение задачи с помощью алгоритма:

Информацию о повторении можно закодировать парой чисел — смещением назад от текущей позиции (offset) и длиной совпадающей подстроки (length).
Алгоритм LZ77 кодирует ссылки блоками из трёх элементов ⟨offset, length, next⟩. В дополнение к двум уже описанным элементам, новый параметр next означает первый символ после найденного совпадающего фрагмента. Если LZ77 не удалось найти совпадение, то считается, что offset = length = 0.

Для эффективного поиска повторов в LZ77 применяется метод *«скользящего окна»* — совпадения ищутся не на всём обработанном префиксе, а в небольшом буфере, состоящем из последних обработанных символов.

Рассмотрим пример кодирования LZ77 на строке *abacabacabadaca* с буфером размера 5. Жирным выделен буфер.

| Строка          | Совпадение | Закодированная последовательность | Примечание                                                                                               |
|-----------------|------------|-----------------------------------|----------------------------------------------------------------------------------------------------------|
| abacabacabadaca |      —     |              ⟨0,0,a⟩              | Буфер пуст                                                                                               |
| **a**bacabacabadaca |      —     |              ⟨0,0,b⟩              | В буфере нет *b*                                                                                           |
| **ab**acabacabadaca |      a     |              ⟨2,1,c⟩              |                                                                                                          |
| **abac**abacabadaca |   abacaba  |              ⟨4,7,d⟩              |                                                             |
| abacaba**cabad**aca |      a     |              ⟨2,1,c⟩              | Последовательность acaaca уже встречалась, но  она находится за пределами окна, и *LZ77* её не находит |
| abacabaca**badac**a |      a     |              ⟨2,1,∅⟩              | Символов в строке больше нет,  поэтому в качестве *next* ставим символ конца строки              |

Результатом кодирования является список полученных троек: 
[⟨0,0,a⟩,⟨0,0,b⟩,⟨2,1,c⟩,⟨4,7,d⟩,⟨2,1,c⟩,⟨2,1,∅⟩].      

#### Идея реализации:

Как было упомянуто выше, ключевой особенностью алгоритма является использование *«скользящего окна»*. 
«Скользящее окно» можно представить в виде буфера (или более сложной динамической структуры данных), который организован так, чтобы запоминать «сказанную» ранее информацию и предоставлять к ней доступ. Таким образом, сам процесс сжимающего кодирования согласно LZ77 напоминает написание программы, команды которой позволяют обращаться к элементам «скользящего окна», и вместо значений сжимаемой последовательности вставлять ссылки на эти значения в «скользящем окне». Следует также отметить, что размер окна кодировщика может быть меньше или равен размеру окна декодировщика, но не наоборот.

#### Достоинства и недостатки:

Благодаря использованию «скользящего окна» при больших объемах ввода алгоритм тратит меньше времени за счет того, что просматривается не вся исходная строка.

К недостаткам можно отнести следующие особенности:

 - невозможность кодирования подстрок, отстоящих друг от друга на расстоянии, большем длины словаря
 - длина подстроки, которую можно закодировать, ограничена размером буфера
 - малая эффективность при кодировании незначительного объёма данных

### Алгоритм RLE

RLE – один из самых старых и самых простых алгоритмов архивации. Сжатие в RLE происходит за счет замены цепочек одинаковых байт на пары ⟨counter, value⟩. 

Одна из реализаций алгоритма такова: 

 - Ищется наименее часто встречающийся байт, его называют префиксом 
 - Делаются замены цепочек одинаковых символов на тройки ⟨prefix, counter, value⟩. Если же этот байт встречается в исходном файле один или два раза подряд, то его заменяют на пару "префикс, 1" или префикс, 2". 
 - Остается одна неиспользованная пара "префикс, 0", которую можно использовать как признак конца упакованных данных.

### Алгоритм Хаффмана

Один из первых алгоритмов эффективного кодирования информации. Идея алгоритма состоит в следующем: зная вероятности появления символов в сообщении, можно описать процедуру построения кодов переменной длины, состоящих из целого количества битов. Символам с большей вероятностью ставятся в соответствие более короткие коды. Коды Хаффмана обладают свойством префиксности, что позволяет однозначно их декодировать.
Этот метод кодирования состоит из двух основных этапов:
 1. Построение оптимального кодового дерева.
 2. Построение отображения код-символ на основе построенного дерева.
 
Классический алгоритм Хаффмана на входе получает таблицу частот встречаемости символов в сообщении. Далее на основании этой таблицы строится дерево кодирования Хаффмана.

 - Символы входного алфавита образуют список свободных узлов. Каждый лист имеет вес, который может быть равен либо вероятности, либо количеству вхождений символа в сжимаемое сообщение.
 - Выбираются два свободных узла дерева с наименьшими весами.
 - Создается их родитель с весом, равным их суммарному весу.
 - Родитель добавляется в список свободных узлов, а два его потомка удаляются из этого списка.
 - Одной дуге, выходящей из родителя, ставится в соответствие бит 1, другой — бит 0. Битовые значения ветвей, исходящих от корня, не зависят от весов потомков.
 - Шаги, начиная со второго, повторяются до тех пор, пока в списке свободных узлов не останется только один свободный узел. Он и будет считаться корнем дерева.
 
### Алгоритм Шеннона–Фано

Данный метод сжатия имеет большое сходство с алгоритмом Хаффмана, который появился на несколько лет позже и является логическим продолжением алгоритма Шеннона. Алгоритм использует коды переменной длины: часто встречающийся символ кодируется кодом меньшей длины, редко встречающийся — кодом большей длины. Коды Шеннона — Фано — префиксные, то есть никакое кодовое слово не является префиксом любого другого. Это свойство позволяет однозначно декодировать любую последовательность кодовых слов.

Основные этапы:
 - Символы первичного алфавита m1 выписывают по убыванию вероятностей.
 - Символы полученного алфавита делят на две части, суммарные вероятности символов которых максимально близки друг другу.
 - В префиксном коде для первой части алфавита присваивается двоичная цифра «0», второй части — «1».
 - Полученные части рекурсивно делятся и их частям назначаются соответствующие двоичные цифры в префиксном коде.

## Выбор алгоритма

Можно сказать, что алгоритмы семейства LZ* представляют собой более сложное обобщение простого и интуитивного способа сжатия данных, используемого в RLE. 

Алгоритмы Хаффмана и Шенонна–Фано схожи, явное их отличие состоит в механизме построения кодового дерева. Несмотря на это, различие кодов для одного и того же алфавита минимально.
Данные алгоритмы чувствительны к частоте появления символов в сообщении. Чем равновероятнее встреча каждого символа (выше энтропия), тем хуже происходит сжатие, так как длина кодов этих символов получается практически одинаковой и почти максимальной.

Алгоритм LZ77, в свою очередь, не зависит напрямую от энтропии сжимаемого сообщения. На сжатие файла здесь влияет повторение подстрок. 
Быстродействие кодера LZ77 сильно зависит от того, каким образом будет осуществляться поиск совпадающей подстроки в словаре. Если искать совпадение полным перебором всех возможных вариантов, то сжатие будет очень медленным. Причем при увеличении размера окна для повышения степени сжатия скорость работы будет пропорционально уменьшаться, так как увеличивается время поиска совпадающей подстроки в буфере. При маленьком размере окна длина кодируемой подстроки и расстояние между подстроками, которые можно закодировать, уменьшаются. 
Для декодера это не имеет значения, так как при декодировании не осуществляется поиск совпадения.
Таким образом, чем больше размер окна, тем лучше сжимаются файлы, а время кодирования, наоборот, увеличивается. Время распаковки файла существенно не отличается.

Из этого следует, что:

 - Алгоритм LZ77 эффективен в тех случаях, когда исходные данные содержат большое количество повторяющихся подстрок. 
 - Алгоритм LZ77 в целом представляет собой обобщение способа сжатия данных, используемого в RLE.
 - Алгоритмы Хаффмана и Шеннона–Фано эффективны только в тех случаях, когда определённые символы в исходных данных встречаются с высокой частотой.
